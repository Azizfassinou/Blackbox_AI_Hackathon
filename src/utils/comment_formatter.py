"""
Comment formatter for GitHub review comments.
"""

import logging
from typing import Dict, Any, List

logger = logging.getLogger(__name__)


class CommentFormatter:
    """Formats review comments for GitHub."""

    def __init__(self):
        """Initialize comment formatter."""
        self.severity_emojis = {
            "critical": "ðŸš¨",
            "high": "âš ï¸",
            "medium": "âš¡",
            "low": "â„¹ï¸",
            "info": "ðŸ’¡",
        }

        self.type_emojis = {
            "bug": "ðŸ›",
            "security": "ðŸ”’",
            "quality": "ðŸ“",
            "performance": "âš¡",
        }

    def format_issue(self, issue: Dict[str, Any]) -> str:
        """
        Format an issue as a GitHub comment.

        Args:
            issue: Issue dictionary with details

        Returns:
            Formatted comment string
        """
        severity = issue.get("severity", "info")
        issue_type = issue.get("type", "quality")
        message = issue.get("message", "Issue detected")
        suggestion = issue.get("suggestion", "")
        code_snippet = issue.get("code_snippet", "")
        doc_links = issue.get("doc_links", [])
        cwe = issue.get("cwe", "")

        # Build comment
        comment = f"{self.type_emojis.get(issue_type, 'ðŸ“')} **{issue_type.title()}** "
        comment += f"{self.severity_emojis.get(severity, 'â„¹ï¸')} *{severity.title()} Severity*\n\n"

        # Add message
        comment += f"{message}\n\n"

        # Add code snippet if available
        if code_snippet:
            comment += f"**Code:**\n```\n{code_snippet}\n```\n\n"

        # Add suggestion
        if suggestion:
            comment += f"**ðŸ’¡ Suggestion:**\n{suggestion}\n\n"

        # Add CWE reference for security issues
        if cwe and issue_type == "security":
            comment += f"**ðŸ”— Reference:** [{cwe}](https://cwe.mitre.org/data/definitions/{cwe.split('-')[1]}.html)\n\n"

        # Add documentation links
        if doc_links:
            comment += self._format_doc_links(doc_links)

        # Add footer
        comment += "\n---\n*ðŸ¤– Generated by Blackbox AI PR Review Bot*"

        return comment

    def format_multiple_issues(
        self, issues: List[Dict[str, Any]], filename: str
    ) -> str:
        """
        Format multiple issues for a single file.

        Args:
            issues: List of issues
            filename: File name

        Returns:
            Formatted comment string
        """
        if not issues:
            return ""

        comment = f"## ðŸ“‹ Review for `{filename}`\n\n"
        comment += f"Found {len(issues)} issue(s):\n\n"

        # Group by severity
        by_severity = {}
        for issue in issues:
            severity = issue.get("severity", "info")
            if severity not in by_severity:
                by_severity[severity] = []
            by_severity[severity].append(issue)

        # Display in severity order
        severity_order = ["critical", "high", "medium", "low", "info"]

        for severity in severity_order:
            if severity in by_severity:
                emoji = self.severity_emojis.get(severity, "â„¹ï¸")
                comment += f"### {emoji} {severity.title()} Severity\n\n"

                for issue in by_severity[severity]:
                    line = issue.get("line", "N/A")
                    message = issue.get("message", "Issue detected")
                    issue_type = issue.get("type", "quality")
                    type_emoji = self.type_emojis.get(issue_type, "ðŸ“")

                    comment += f"- **Line {line}** {type_emoji} {message}\n"

                comment += "\n"

        comment += "---\n*ðŸ¤– Generated by Blackbox AI PR Review Bot*\n"

        return comment

    def format_summary_comment(
        self,
        total_files: int,
        total_issues: int,
        severity_breakdown: Dict[str, int],
        top_issues: List[Dict[str, Any]],
        diff_summary: Dict[str, Any] = None,
        code_quality_overview: Dict[str, Any] = None,
    ) -> str:
        """
        Format a summary comment for the entire PR with diff information.

        Args:
            total_files: Total number of files reviewed
            total_issues: Total number of issues found
            severity_breakdown: Dictionary of severity counts
            top_issues: List of most important issues
            diff_summary: Summary of changes made in the PR
            code_quality_overview: Overall code quality assessment

        Returns:
            Formatted summary comment
        """
        comment = "## ðŸ¤– Blackbox AI Code Review Summary\n\n"

        # Overall status with code quality
        if severity_breakdown.get("critical", 0) > 0:
            comment += "**Status:** ðŸš¨ Critical issues found - review required before merge\n"
        elif severity_breakdown.get("high", 0) > 0:
            comment += "**Status:** âš ï¸ High priority issues found - please address\n"
        elif total_issues > 0:
            comment += "**Status:** âš¡ Minor issues found - consider addressing\n"
        else:
            comment += "**Status:** âœ… No critical issues found\n"

        # Add code quality score if available
        if code_quality_overview and code_quality_overview.get("average_score"):
            score = code_quality_overview["average_score"]
            comment += f"**Code Quality:** {score} grade\n\n"
        else:
            comment += "\n"

        # Diff Summary
        if diff_summary:
            comment += "### ðŸ“Š Changes Overview\n\n"
            comment += f"- **Files changed:** {total_files}\n"
            comment += f"- **Lines added:** +{diff_summary.get('total_additions', 0)}\n"
            comment += f"- **Lines removed:** -{diff_summary.get('total_deletions', 0)}\n"
            comment += f"- **Change complexity:** {diff_summary.get('overall_complexity', 'Unknown')}\n\n"
            
            # Significant changes
            if diff_summary.get('significant_files'):
                comment += "**Files with significant changes:**\n"
                for file_info in diff_summary['significant_files'][:5]:
                    comment += f"- `{file_info['filename']}` (+{file_info.get('additions', 0)}/-{file_info.get('deletions', 0)})\n"
                comment += "\n"

        # Issue statistics
        comment += "### ðŸ” Review Results\n\n"
        comment += f"- **Total issues found:** {total_issues}\n"
        comment += f"- **Files with issues:** {len([f for f in severity_breakdown.keys() if severity_breakdown[f] > 0])}\n\n"

        # Severity breakdown
        if total_issues > 0:
            comment += "**Issues by severity:**\n"
            for severity in ["critical", "high", "medium", "low", "info"]:
                count = severity_breakdown.get(severity, 0)
                if count > 0:
                    emoji = self.severity_emojis.get(severity, "â„¹ï¸")
                    comment += f"- {emoji} {severity.title()}: {count}\n"
            comment += "\n"

            # Top issues with diff context
            comment += "### âš ï¸ Priority Issues\n\n"
            for i, issue in enumerate(top_issues[:5], 1):
                severity = issue.get("severity", "info")
                emoji = self.severity_emojis.get(severity, "â„¹ï¸")
                message = issue.get("message", "Issue detected")
                file = issue.get("file", "unknown")
                line = issue.get("line", "N/A")
                
                # Mark if issue is related to diff changes
                diff_marker = " ðŸ”„" if issue.get("diff_related", False) else ""
                
                comment += f"{i}. {emoji} **{file}:{line}**{diff_marker} - {message}\n"
            
            if len(top_issues) > 5:
                comment += f"*... and {len(top_issues) - 5} more issues*\n"
            comment += "\n"

        # Code quality insights
        if code_quality_overview and code_quality_overview.get("main_concerns"):
            comment += "### ðŸ’¡ Code Quality Insights\n\n"
            comment += "**Main areas for improvement:**\n"
            for concern in code_quality_overview["main_concerns"][:5]:
                comment += f"- {concern}\n"
            comment += "\n"

        # Recommendations
        comment += "### ðŸ“‹ Recommendations\n\n"
        
        if severity_breakdown.get("critical", 0) > 0:
            comment += "ðŸš¨ **Critical:** Address critical security and functionality issues before merging\n"
        
        if severity_breakdown.get("high", 0) > 0:
            comment += "âš ï¸ **High Priority:** Review and fix high-severity issues\n"
            
        if total_issues > 0:
            comment += "ðŸ” **Review:** Check inline comments for detailed feedback and suggestions\n"
        else:
            comment += "âœ… **Good to go:** Code looks clean and follows best practices\n"

        # Footer
        comment += "\n---\n"
        comment += "*ðŸ’» Detailed feedback available in inline comments*  \n"
        comment += "*ðŸ”„ Issues marked with ðŸ”„ are in changed code sections*  \n"
        comment += "*ðŸ¤– Generated by Blackbox AI PR Review Bot*\n"

        return comment

    def _format_doc_links(self, doc_links: List[Dict[str, str]]) -> str:
        """Format documentation links."""
        if not doc_links:
            return ""

        formatted = "**ðŸ“š Related Documentation:**\n"
        for doc in doc_links[:3]:  # Limit to 3 links
            title = doc.get("title", "Documentation")
            url = doc.get("url", "#")
            description = doc.get("description", "")

            formatted += f"- [{title}]({url})"
            if description:
                formatted += f" - {description}"
            formatted += "\n"

        formatted += "\n"
        return formatted

    def format_approval_comment(self) -> str:
        """Format an approval comment."""
        return """## âœ… Approved by Blackbox AI

This PR looks good! No critical issues were found.

**Review Summary:**
- Code quality: Good
- Security: No vulnerabilities detected
- Best practices: Followed

Great work! ðŸŽ‰

---
*ðŸ¤– Generated by Blackbox AI PR Review Bot*
"""

    def format_request_changes_comment(
        self, critical_issues: List[Dict[str, Any]]
    ) -> str:
        """Format a request changes comment."""
        comment = "## âš ï¸ Changes Requested by Blackbox AI\n\n"
        comment += (
            "Critical issues were found that should be addressed before merging.\n\n"
        )

        comment += "### ðŸš¨ Critical Issues:\n\n"
        for i, issue in enumerate(critical_issues[:10], 1):
            message = issue.get("message", "Issue detected")
            file = issue.get("file", "unknown")
            line = issue.get("line", "N/A")

            comment += f"{i}. **{file}:{line}** - {message}\n"

        comment += "\n---\n"
        comment += "*Please address these issues and update the PR.*\n\n"
        comment += "*ðŸ¤– Generated by Blackbox AI PR Review Bot*\n"

        return comment

    def truncate_comment(self, comment: str, max_length: int = 65536) -> str:
        """
        Truncate comment if it exceeds GitHub's limit.

        Args:
            comment: Comment text
            max_length: Maximum length (GitHub limit is 65536)

        Returns:
            Truncated comment
        """
        if len(comment) <= max_length:
            return comment

        truncated = comment[: max_length - 200]
        truncated += "\n\n---\n\n"
        truncated += (
            "*âš ï¸ Comment truncated due to length. See full analysis in artifacts.*\n"
        )
        truncated += "*ðŸ¤– Generated by Blackbox AI PR Review Bot*\n"

        return truncated
